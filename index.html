<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>九宫格切图工具</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
/* CSS保持不变 */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
    -webkit-tap-highlight-color: transparent;
    -webkit-text-size-adjust: 100%;
}
    /* 华为、小米等Android手机兼容性优化 */
    body {
        background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
        color: #2d3748;
        min-height: 100vh;
        min-height: -webkit-fill-available; /* 解决iOS Safari 100vh问题 */
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 15px;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        -webkit-overflow-scrolling: touch; /* 启用弹性滚动 */
        overflow-x: hidden;
    }
    
    /* 修复移动端100vh问题 */
    html {
        height: -webkit-fill-available;
    }
    
    .container {
        width: 100%;
        max-width: 1000px;
        background: white;
        border-radius: 20px;
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.08);
        overflow: hidden;
        position: relative;
        margin: auto;
    }
    
    .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 25px 30px;
        text-align: center;
        position: relative;
        overflow: hidden;
    }
    
    .header::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(255,255,255,0.1) 1px, transparent 1px);
        background-size: 25px 25px;
        opacity: 0.2;
    }
    
    .header-content {
        max-width: 600px;
        margin: 0 auto;
        position: relative;
        z-index: 1;
    }
    
    h1 {
        font-size: clamp(1.3rem, 4vw, 2rem); /* 响应式字体大小 */
        font-weight: 700;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 15px;
        letter-spacing: -0.3px;
        flex-wrap: wrap;
    }
    
    h1 i {
        font-size: clamp(1.2rem, 3.5vw, 1.8rem);
        filter: drop-shadow(0 3px 6px rgba(0,0,0,0.2));
    }
    
    .subtitle {
        font-size: clamp(0.8rem, 2.5vw, 0.95rem);
        opacity: 0.95;
        line-height: 1.5;
        font-weight: 300;
        text-shadow: 0 1px 3px rgba(0,0,0,0.1);
        margin-bottom: 8px;
        padding: 0 10px;
    }
    
    .hermit-brand {
        font-size: clamp(0.7rem, 2vw, 0.85rem);
        opacity: 0.85;
        font-weight: 400;
        letter-spacing: 1px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 5px 14px;
        border-radius: 20px;
        background: rgba(255, 255, 255, 0.15);
        backdrop-filter: blur(5px);
        margin-top: 4px;
    }
    
    .main-content {
        padding: clamp(20px, 4vw, 30px);
        display: flex;
        flex-direction: column;
        min-height: 650px;
    }
    
    /* 更新：上传区域宽度调整为80%，高度适当减小 */
    .upload-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        margin-bottom: 30px;
        min-height: 160px; /* 更新：适当减小高度 */
        width: 80%; /* 新增：宽度80% */
        max-width: 800px; /* 新增：限制最大宽度 */
        margin-left: auto; /* 新增：居中 */
        margin-right: auto; /* 新增：居中 */
    }
    
    .upload-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        border: 3px dashed #667eea;
        border-radius: 18px;
        padding: clamp(18px, 3vw, 25px) clamp(15px, 3vw, 25px); /* 更新：减小内边距 */
        background: linear-gradient(135deg, #f8faff 0%, #f0f4ff 100%);
        cursor: pointer;
        transition: all 0.3s ease;
        height: 100%;
        position: relative;
        overflow: hidden;
        -webkit-user-select: none;
        user-select: none;
        width: 100%; /* 新增：确保占满父容器 */
    }
    
    .upload-area:hover {
        background: linear-gradient(135deg, #f0f4ff 0%, #e6f0ff 100%);
        transform: translateY(-3px);
        box-shadow: 0 15px 30px rgba(102, 126, 234, 0.1);
    }
    
    .upload-icon {
        font-size: clamp(2rem, 5vw, 2.5rem); /* 更新：适当减小图标大小 */
        color: #667eea;
        margin-bottom: 15px; /* 更新：减小下边距 */
        filter: drop-shadow(0 5px 12px rgba(102, 126, 234, 0.25));
    }
    
    .upload-text {
        text-align: center;
        color: #4a5568;
        max-width: 400px;
        padding: 0 10px;
    }
    
    .upload-text h3 {
        font-size: clamp(1rem, 3vw, 1.2rem); /* 更新：适当减小字体大小 */
        color: #2d3748;
        margin-bottom: 10px; /* 更新：减小下边距 */
        font-weight: 600;
    }
    
    .upload-text p {
        font-size: clamp(0.75rem, 2.2vw, 0.85rem); /* 更新：适当减小字体大小 */
        line-height: 1.4; /* 更新：减小行高 */
        margin-bottom: 6px; /* 更新：减小下边距 */
        color: #718096;
    }
    
    /* 更新：预览区域宽度调整为80%，保持实际显示区域与上一版本一致 */
    .preview-section {
        flex: 2;
        display: flex;
        flex-direction: column;
        margin-bottom: 30px;
        min-height: 420px; /* 更新：减小最小高度 */
        width: 80%; /* 新增：宽度80% */
        max-width: 800px; /* 新增：限制最大宽度 */
        margin-left: auto; /* 新增：居中 */
        margin-right: auto; /* 新增：居中 */
    }
    
    .section-title {
        font-size: clamp(1.1rem, 3.5vw, 1.4rem);
        color: #2d3748;
        margin-bottom: 18px;
        display: flex;
        align-items: center;
        gap: 12px;
        font-weight: 600;
    }
    
    .section-title i {
        color: #667eea;
        font-size: clamp(1.2rem, 3.5vw, 1.5rem);
    }
    
    .preview-container {
        flex: 1;
        background: linear-gradient(135deg, #f8faff 0%, #f0f4ff 100%);
        border-radius: 18px;
        padding: 15px; /* 更新：增加内边距，让实际显示区域相对更小 */
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
        border: 2px solid #e2e8f0;
        box-shadow: inset 0 1px 6px rgba(0, 0, 0, 0.04), 0 8px 30px rgba(0, 0, 0, 0.15);
        position: relative;
        overflow: hidden;
        min-height: 450px; /* 更新：减小最小高度 */
        width: 100%; /* 新增：确保占满父容器 */
    }
    
    .canvas-wrapper {
        position: relative;
        overflow: visible;
        border-radius: 12px;
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
        background: #ffffff;
        border: 2px solid rgba(255, 255, 255, 0.8);
        width: 100%;
        height: 100%;
        max-width: 500px; /* 更新：减小最大宽度，与上一版本保持一致 */
        max-height: 500px; /* 更新：减小最大高度，与上一版本保持一致 */
        aspect-ratio: 1/1; /* 新增：确保1:1比例 */
        margin: 0 auto; /* 新增：居中显示 */
    }
    
    #imageCanvas {
        display: block;
        background: #ffffff;
        cursor: move;
        touch-action: none;
        max-width: 100%;
        max-height: 100%;
        -webkit-user-select: none;
        user-select: none;
    }
    
    #gridCanvas {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
        width: 100%;
        height: 100%;
    }
    
    .preview-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 15px;
        justify-content: center;
        align-items: center;
        width: 100%; /* 新增：确保占满父容器 */
    }
    
    /* 更新：按钮样式修复 - 去除点击色块 */
    .control-btn {
        background: linear-gradient(135deg, #f5f5f7 0%, #e5e5ea 100%);
        color: #5a5a5a;
        border: none;
        padding: 8px 32px;
        border-radius: 20px;
        font-size: clamp(0.8rem, 2.5vw, 0.9rem);
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        min-width: 180px;
        justify-content: center;
        -webkit-tap-highlight-color: transparent; /* 新增：去除点击色块 */
        tap-highlight-color: transparent; /* 新增：去除点击色块 */
        touch-action: manipulation;
    }
    
    .control-btn:hover {
        background: linear-gradient(135deg, #e5e5ea 0%, #d5d5dc 100%);
        color: #333333;
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
    }
    
    .control-btn:active {
        transform: translateY(0);
        background: linear-gradient(135deg, #d5d5dc 0%, #c5c5cc 100%);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }
    
    .preview-hint {
        text-align: center;
        margin-top: 12px;
        color: #718096;
        font-size: clamp(0.8rem, 2.5vw, 0.9rem);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        flex-wrap: wrap;
        padding: 0 10px;
        line-height: 1.5;
        width: 100%; /* 新增：确保占满父容器 */
    }
    
    .preview-hint i {
        color: #48bb78;
    }
    
    .action-section {
        margin-top: 25px;
        text-align: center;
        width: 100%; /* 新增：确保占满父容器 */
    }
    
    .action-buttons {
        display: flex;
        gap: 18px;
        justify-content: center;
        flex-wrap: wrap;
        width: 100%; /* 新增：确保占满父容器 */
    }
    
    /* 更新：打包下载和选择下载按钮样式修复 */
    .action-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: clamp(12px, 3vw, 16px) clamp(25px, 4vw, 35px);
        border-radius: 50px;
        font-size: clamp(0.9rem, 2.8vw, 1rem);
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        display: inline-flex;
        align-items: center;
        gap: 12px;
        box-shadow: 0 12px 25px rgba(102, 126, 234, 0.2);
        min-width: 240px;
        justify-content: center;
        letter-spacing: 0.3px;
        position: relative;
        overflow: hidden;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent; /* 新增：去除点击色块 */
        tap-highlight-color: transparent; /* 新增：去除点击色块 */
    }
    
    .action-btn::after {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
        transition: left 0.6s;
    }
    
    .action-btn:hover:not(:disabled),
    .action-btn:active:not(:disabled) {
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 18px 40px rgba(102, 126, 234, 0.3);
    }
    
    .action-btn:hover:not(:disabled)::after {
        left: 100%;
    }
    
    .action-btn:disabled {
        background: #cbd5e0;
        cursor: not-allowed;
        transform: none;
        box-shadow: 0 5px 12px rgba(0, 0, 0, 0.08);
    }
    
    .secondary-btn {
        background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        box-shadow: 0 12px 25px rgba(72, 187, 120, 0.2);
    }
    
    .secondary-btn:hover:not(:disabled),
    .secondary-btn:active:not(:disabled) {
        box-shadow: 0 18px 40px rgba(72, 187, 120, 0.3);
    }
    
    .action-hint {
        margin-top: 18px;
        color: #718096;
        font-size: clamp(0.8rem, 2.5vw, 0.9rem);
        line-height: 1.5;
        text-align: center;
        width: 100%;
        padding: 0 10px;
    }
    
    .progress-container {
        display: none;
        margin-top: 20px;
        max-width: 450px;
        margin-left: auto;
        margin-right: auto;
        width: 100%;
    }
    
    .progress-bar {
        width: 100%;
        height: 6px;
        background: #e2e8f0;
        border-radius: 3px;
        overflow: hidden;
        margin-bottom: 10px;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.08);
    }
    
    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        width: 0%;
        transition: width 0.3s ease;
        border-radius: 3px;
    }
    
    .progress-text {
        text-align: center;
        font-size: clamp(0.8rem, 2.5vw, 0.9rem);
        color: #4a5568;
        font-weight: 500;
    }
    
    /* 修改底部样式 */
    .footer {
        text-align: center;
        padding: 22px;
        color: #718096;
        border-top: 1px solid #e2e8f0;
        font-size: clamp(0.75rem, 2.2vw, 0.85rem);
        background: #f8fafc;
        display: flex;
        flex-direction: column;
        gap: 12px;
        line-height: 1.6;
        width: 100%;
    }
    
    .footer i {
        color: #667eea;
        margin-right: 5px;
    }
    
    /* 微信作者信息样式 */
    .footer .author-wechat {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        margin-bottom: 0;
    }
    
    .footer .author-wechat i {
        color: #4CAF50;
    }
    
    .footer .avatar-icon {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 0.7rem;
        font-weight: bold;
        margin-right: 6px;
    }
    
    /* Vibe Coding 样式 */
    .footer .vibe-coding {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        color: #718096;
        font-weight: normal;
    }
    
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        padding: 20px;
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
    }
    
    .modal-content {
        background: white;
        padding: 28px;
        border-radius: 22px;
        max-width: 520px;
        width: 95%;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
        position: relative;
        border: 1px solid #e2e8f0;
        animation: modalAppear 0.3s ease-out;
        max-height: 90vh;
        overflow-y: auto;
    }
    
    @keyframes modalAppear {
        from {
            opacity: 0;
            transform: translateY(20px) scale(0.97);
        }
        to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }
    
    .modal-header {
        margin-bottom: 22px;
        text-align: center;
    }
    
    .modal-title {
        font-size: clamp(1.2rem, 4vw, 1.5rem);
        color: #2d3748;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
    }
    
    .modal-title i {
        color: #48bb78;
        font-size: clamp(1.3rem, 4vw, 1.7rem);
    }
    
    .tile-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
        margin-bottom: 30px;
    }
    
    /* 更新：弹窗按钮样式修复 */
    .tile-btn {
        padding: 20px 8px;
        background: linear-gradient(135deg, #f8fafc 0%, #edf2f7 100%);
        border: 2px solid #e2e8f0;
        border-radius: 14px;
        font-weight: 600;
        color: #4a5568;
        cursor: pointer;
        transition: all 0.25s ease;
        font-size: clamp(0.9rem, 2.8vw, 1.1rem);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 6px;
        min-height: 85px;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent; /* 新增：去除点击色块 */
        tap-highlight-color: transparent; /* 新增：去除点击色块 */
    }
    
    .tile-btn:hover {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: #667eea;
        transform: translateY(-4px);
        box-shadow: 0 12px 25px rgba(102, 126, 234, 0.18);
    }
    
    .tile-btn:active {
        transform: translateY(-2px);
    }
    
    .tile-btn span {
        font-size: clamp(0.85rem, 2.5vw, 1rem);
        font-weight: 600;
    }
    
    .modal-actions {
        display: flex;
        gap: 12px;
        justify-content: center;
        flex-wrap: wrap;
    }
    
    /* 更新：弹窗按钮样式修复 */
    .modal-btn {
        padding: 14px 28px;
        border-radius: 50px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
        font-size: 1rem;
        border: none;
        min-width: 150px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent; /* 新增：去除点击色块 */
        tap-highlight-color: transparent; /* 新增：去除点击色块 */
    }
    
    .modal-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        box-shadow: 0 8px 20px rgba(102, 126, 234, 0.25);
    }
    
    .modal-secondary {
        background: #f8fafc;
        color: #4a5568;
        border: 2px solid #e2e8f0;
    }
    
    .modal-btn:hover,
    .modal-btn:active {
        transform: translateY(-2px);
        box-shadow: 0 12px 25px rgba(0, 0, 0, 0.12);
    }
    
    /* 响应式设计 - 优化移动端体验 */
    @media (max-width: 768px) {
        body {
            padding: 10px;
            min-height: -webkit-fill-available;
        }
        
        .container {
            border-radius: 18px;
            max-width: 100%;
        }
        
        .header {
            padding: 20px 15px;
        }
        
        h1 {
            gap: 10px;
            margin-bottom: 6px;
        }
        
        .subtitle {
            margin-bottom: 6px;
        }
        
        .hermit-brand {
            padding: 4px 12px;
        }
        
        .main-content {
            padding: 20px 15px;
        }
        
        /* 移动端上传区域调整 */
        .upload-section {
            min-height: 150px; /* 更新：移动端适当减小 */
            margin-bottom: 20px;
            width: 100%; /* 移动端恢复全宽 */
            max-width: none;
        }
        
        /* 移动端预览区域调整 */
        .preview-section {
            min-height: 380px; /* 更新：移动端适当减小 */
            margin-bottom: 20px;
            width: 100%; /* 移动端恢复全宽 */
            max-width: none;
        }
        
        .preview-container {
            min-height: 380px; /* 更新：移动端适当减小 */
            padding: 12px;
        }
        
        .upload-area {
            padding: 18px 15px;
        }
        
        .upload-icon {
            margin-bottom: 12px;
            font-size: 2.2rem;
        }
        
        .section-title {
            margin-bottom: 15px;
        }
        
        .preview-controls {
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .action-buttons {
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }
        
        .action-btn {
            width: 100%;
            max-width: 320px;
            padding: 14px 20px;
        }
        
        /* 更新：移动端弹窗适配优化 */
        .modal-content {
            padding: 20px 15px;
            width: 95%;
            max-width: 90%;
        }
        
        .tile-grid {
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        .tile-btn {
            min-height: 70px;
            padding: 12px 6px;
            font-size: clamp(0.8rem, 2.5vw, 0.95rem);
        }
        
        .tile-btn span {
            font-size: clamp(0.75rem, 2.2vw, 0.85rem);
        }
        
        .modal-actions {
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .modal-btn {
            width: 100%;
            max-width: 260px;
            padding: 12px 20px;
            font-size: 0.9rem;
        }
        
        /* 底部移动端调整 */
        .footer {
            gap: 10px;
            padding: 18px 15px;
        }
        
        /* 移动端恢复初始位置按钮调整 */
        .control-btn {
            min-width: 200px;
            padding: 8px 24px;
        }
        
        /* 移动端九宫格预览区域进一步优化 */
        .canvas-wrapper {
            max-width: 400px;
            max-height: 400px;
        }
    }
    
    @media (max-width: 480px) {
        .container {
            border-radius: 16px;
        }
        
        .header {
            padding: 18px 12px;
        }
        
        h1 {
            flex-direction: row;
        }
        
        .hermit-brand {
            font-size: 0.75rem;
        }
        
        .main-content {
            padding: 18px 12px;
        }
        
        .upload-section {
            min-height: 140px;
        }
        
        .preview-section {
            min-height: 350px;
        }
        
        .preview-container {
            min-height: 350px;
            padding: 10px;
        }
        
        .upload-text h3 {
            font-size: 1rem;
        }
        
        .upload-text p {
            font-size: 0.8rem;
        }
        
        .section-title {
            font-size: 1.2rem;
        }
        
        .action-btn {
            padding: 12px 18px;
            font-size: 0.95rem;
        }
        
        /* 更新：小屏幕弹窗进一步优化 */
        .modal-content {
            padding: 18px 12px;
            max-width: 95%;
        }
        
        .tile-grid {
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }
        
        .tile-btn {
            min-height: 65px;
            padding: 10px 4px;
            font-size: 0.85rem;
        }
        
        .tile-btn span {
            font-size: 0.8rem;
        }
        
        .modal-title {
            font-size: 1.3rem;
        }
        
        .modal-btn {
            padding: 10px 16px;
            font-size: 0.85rem;
            min-width: 120px;
        }
        
        .footer {
            padding: 16px 12px;
            gap: 8px;
        }
        
        /* 移动端恢复初始位置按钮调整 */
        .control-btn {
            min-width: 180px;
            padding: 8px 20px;
            font-size: 0.85rem;
        }
        
        /* 小屏幕九宫格预览区域进一步优化 */
        .canvas-wrapper {
            max-width: 350px;
            max-height: 350px;
        }
    }
    
    @media (max-width: 360px) {
        h1 {
            font-size: 1.3rem;
        }
        
        .upload-section {
            min-height: 130px;
        }
        
        .preview-section {
            min-height: 320px;
        }
        
        .preview-container {
            min-height: 320px;
            padding: 8px;
        }
        
        .upload-text h3 {
            font-size: 0.95rem;
        }
        
        /* 更新：超小屏幕弹窗优化 */
        .modal-content {
            padding: 15px 10px;
        }
        
        .tile-grid {
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
        }
        
        .tile-btn {
            min-height: 60px;
            padding: 8px 3px;
            font-size: 0.8rem;
        }
        
        .tile-btn span {
            font-size: 0.75rem;
        }
        
        .modal-title {
            font-size: 1.2rem;
        }
        
        .modal-btn {
            padding: 8px 14px;
            font-size: 0.8rem;
            min-width: 110px;
        }
        
        .control-btn {
            min-width: 160px;
            padding: 8px 16px;
            font-size: 0.8rem;
        }
        
        .footer {
            gap: 6px;
            padding: 14px 10px;
        }
        
        /* 超小屏幕九宫格预览区域进一步优化 */
        .canvas-wrapper {
            max-width: 300px;
            max-height: 300px;
        }
    }
    
    /* iOS Safari 特定修复 */
    @supports (-webkit-touch-callout: none) {
        body {
            min-height: -webkit-fill-available;
        }
        
        .action-btn, .modal-btn, .tile-btn, .control-btn {
            cursor: pointer;
        }
        
        .upload-area:hover {
            transform: none;
        }
        
        .upload-area:active {
            background: linear-gradient(135deg, #f0f4ff 0%, #e6f0ff 100%);
            transform: translateY(-1px);
        }
        
        /* iOS 触摸反馈优化 */
        .control-btn:active {
            background: linear-gradient(135deg, #d5d5dc 0%, #c5c5cc 100%);
            transform: scale(0.98);
        }
        
        #imageCanvas {
            cursor: pointer;
        }
        
        /* iOS 点击高亮颜色 - 已设置为透明 */
        button, a {
            -webkit-tap-highlight-color: transparent;
        }
    }
    
    /* Android Chrome 特定修复 */
    @media screen and (max-width: 768px) {
        input, select, textarea {
            font-size: 16px !important;
        }
        
        /* 防止Android长按选择文本 */
        .upload-area, .control-btn, .action-btn, .tile-btn {
            -webkit-user-select: none;
            user-select: none;
        }
    }
    
    /* 华为EMUI、小米MIUI、OPPO ColorOS、VIVO FuntouchOS兼容性 */
    @media (hover: none) and (pointer: coarse) {
        /* 触摸设备优化 */
        .control-btn, .action-btn, .tile-btn {
            min-height: 44px;
        }
        
        .upload-area {
            min-height: 60px;
        }
        
        /* 增加触摸目标间距 */
        .action-buttons {
            gap: 15px;
        }
        
        .preview-controls {
            gap: 12px;
        }
        
        /* 优化触摸反馈 */
        .control-btn:active, .action-btn:active, .tile-btn:active {
            opacity: 0.8;
            transform: scale(0.98);
        }
    }
    
    /* 深色模式支持 */
    @media (prefers-color-scheme: dark) {
        .container {
            background: #1a202c;
            color: #e2e8f0;
        }
        
        .preview-container {
            background: #2d3748;
            border-color: #4a5568;
        }
        
        .canvas-wrapper {
            background: #2d3748;
            border-color: #4a5568;
        }
        
        #imageCanvas {
            background: #2d3748;
        }
        
        .footer {
            background: #1a202c;
            border-top-color: #4a5568;
            color: #a0aec0;
        }
        
        /* 深色模式下的Vibe Coding颜色 */
        .footer .vibe-coding {
            color: #a0aec0;
        }
        
        /* 深色模式下的恢复初始位置按钮 */
        .control-btn {
            background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
            color: #e2e8f0;
            border: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        }
        
        .control-btn:hover {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #ffffff;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
        }
        
        .control-btn:active {
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
    }
</style>

</head>
<body>
<div class="container">
<div class="header">
<div class="header-content">
<h1><i class="fas fa-th-large"></i> 九宫格切图工具</h1>
<p class="subtitle">高清九宫格切图 • 纯本地处理 • 手机电脑均适配</p>
<div class="hermit-brand">
Hermit 出品
</div>
</div>
</div>

<div class="main-content">
    <div class="upload-section">
        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">
                <i class="fas fa-cloud-upload-alt"></i>
            </div>
            <div class="upload-text">
                <h3>点击或拖放上传图片</h3>
                <p>支持 JPG、PNG、GIF、WebP 格式</p>
                <p>最大支持 100MB 文件大小</p>
            </div>
        </div>
    </div>
    
    <div class="preview-section">
        <h2 class="section-title"><i class="fas fa-eye"></i> 九宫格预览</h2>
        <div class="preview-container">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="imageCanvas"></canvas>
                <canvas id="gridCanvas"></canvas>
            </div>
        </div>
        <div class="preview-controls">
            <button class="control-btn" id="resetBtn">
                <i class="fas fa-redo"></i> 恢复初始位置
            </button>
        </div>
        <p class="preview-hint">
            <i class="fas fa-info-circle"></i> 
            <span>拖动图片调整位置 • 滚轮/双指缩放 • 九宫格内为裁剪区域</span>
        </p>
    </div>
    
    <div class="action-section">
        <div class="action-buttons">
            <button class="action-btn" id="downloadBtn" disabled>
                <i class="fas fa-file-archive"></i> 打包下载
            </button>
            <button class="action-btn secondary-btn" id="downloadSingleBtn" disabled>
                <i class="fas fa-cubes"></i> 选择下载
            </button>
        </div>
        <p class="action-hint">高清质量 • 纯本地处理 • 数据不上传云端</p>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">正在处理图片...</div>
        </div>
    </div>
</div>

<div class="footer">
    <p><span class="avatar-icon">H</span> Hermit 出品 | <span class="vibe-coding">Vibe Coding</span> | 全部代码由DeepSeek生成</p>
    <p class="author-wechat">
        <i class="fab fa-weixin"></i> 作者微信：avatarhelp | 欢迎交流或提bug
    </p>
    <p><i class="fas fa-mobile-alt"></i> 完美适配手机与电脑设备</p>
</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script>
    // 应用程序状态
    const state = {
        image: null,
        originalImage: null,
        imageCanvas: null,
        imageCtx: null,
        gridCanvas: null,
        gridCtx: null,
        fileName: '',
        originalImageSize: { width: 0, height: 0 },
        minDimension: 0,
        cropState: {
            scale: 1.0,
            offsetX: 0,
            offsetY: 0,
            defaultScale: 1.0,
            defaultOffsetX: 0,
            defaultOffsetY: 0,
            isDragging: false,
            lastX: 0,
            lastY: 0,
            lastDistance: 0,
            lastScale: 1.0,
            minScale: 0.1,
            maxScale: 5.0,
            gridSize: 0,
            gridX: 0,
            gridY: 0,
            minOffsetX: 0,
            maxOffsetX: 0,
            minOffsetY: 0,
            maxOffsetY: 0,
            isInBounds: true,
            minAllowedScale: 0.1
        }
    };

    const elements = {
        uploadArea: document.getElementById('uploadArea'),
        imageCanvas: document.getElementById('imageCanvas'),
        gridCanvas: document.getElementById('gridCanvas'),
        canvasWrapper: document.getElementById('canvasWrapper'),
        downloadBtn: document.getElementById('downloadBtn'),
        downloadSingleBtn: document.getElementById('downloadSingleBtn'),
        progressContainer: document.getElementById('progressContainer'),
        progressFill: document.getElementById('progressFill'),
        progressText: document.getElementById('progressText'),
        resetBtn: document.getElementById('resetBtn')
    };

    const chineseNumbers = ['第一张', '第二张', '第三张', '第四张', '第五张', '第六张', '第七张', '第八张', '第九张'];

    // 新增：防止重复上传的标记
    let isUploading = false;
    let lastUploadTime = 0;
    const UPLOAD_COOLDOWN = 1000; // 1秒冷却时间

    function init() {
        state.imageCanvas = elements.imageCanvas;
        state.imageCtx = state.imageCanvas.getContext('2d');
        state.gridCanvas = elements.gridCanvas;
        state.gridCtx = state.gridCanvas.getContext('2d');
        
        updateCanvasSize();
        setupEventListeners();
        drawPlaceholder();
        
        window.addEventListener('resize', handleResize);
        initTouchEvents();
        
        // 移动端特殊处理
        if ('ontouchstart' in window) {
            optimizeForMobile();
        }
    }

    // 移动端优化
    function optimizeForMobile() {
        // 增加触摸目标大小
        document.querySelectorAll('button').forEach(btn => {
            btn.style.minHeight = '44px';
        });
        
        // 优化滚动体验
        document.body.style.webkitOverflowScrolling = 'touch';
        
        // 防止双击缩放
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function(event) {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    }

    function updateCanvasSize() {
        const container = document.querySelector('.preview-container');
        const wrapper = elements.canvasWrapper;
        
        // 考虑80%宽度限制和容器内边距
        const containerWidth = container.clientWidth - 30; // 减去内边距
        const containerHeight = container.clientHeight - 30; // 减去内边距
        
        // 确保正方形，取宽度和高度的最小值
        const size = Math.min(containerWidth, containerHeight, 500); // 最大500px，与上一版本保持一致
        
        wrapper.style.width = size + 'px';
        wrapper.style.height = size + 'px';
        
        // 高清Canvas，支持Retina屏幕
        const dpr = window.devicePixelRatio || 1;
        state.imageCanvas.width = size * dpr;
        state.imageCanvas.height = size * dpr;
        state.gridCanvas.width = size * dpr;
        state.gridCanvas.height = size * dpr;
        
        // 调整CSS尺寸
        state.imageCanvas.style.width = size + 'px';
        state.imageCanvas.style.height = size + 'px';
        state.gridCanvas.style.width = size + 'px';
        state.gridCanvas.style.height = size + 'px';
        
        // 缩放Canvas上下文
        if (dpr !== 1) {
            state.imageCtx.scale(dpr, dpr);
            state.gridCtx.scale(dpr, dpr);
        }
        
        state.cropState.gridSize = size;
        state.cropState.gridX = 0;
        state.cropState.gridY = 0;
    }

    function handleResize() {
        updateCanvasSize();
        if (state.image) {
            // 重新计算缩放边界
            calculateMinScale();
            updateBoundaries();
            clampOffsetToBoundaries();
            drawImage();
            drawGrid();
        } else {
            drawPlaceholder();
        }
    }

    function initTouchEvents() {
        // 防止iOS双击缩放
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function(event) {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // 防止Android长按菜单
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
        });
    }

    function setupEventListeners() {
        // 优化触摸事件 - 修复重复触发问题
        elements.uploadArea.addEventListener('click', handleUploadClick);
        
        // 移动端触摸事件处理 - 使用更可靠的方式
        elements.uploadArea.addEventListener('touchstart', function(e) {
            // 只处理单点触摸，防止多点触摸误触发
            if (e.touches.length === 1) {
                // 轻微延迟，防止快速连续触发
                setTimeout(() => {
                    handleUploadClick();
                }, 50);
            }
        }, { passive: true });
        
        elements.uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.uploadArea.style.background = 'linear-gradient(135deg, #e6f0ff 0%, #d6e4ff 100%)';
        });
        
        elements.uploadArea.addEventListener('dragleave', () => {
            elements.uploadArea.style.background = 'linear-gradient(135deg, #f8faff 0%, #f0f4ff 100%)';
        });
        
        elements.uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.uploadArea.style.background = 'linear-gradient(135deg, #f8faff 0%, #f0f4ff 100%)';
            
            if (e.dataTransfer.files.length) {
                handleFileSelect({ target: { files: e.dataTransfer.files } });
            }
        });
        
        elements.resetBtn.addEventListener('click', resetCrop);
        elements.downloadBtn.addEventListener('click', downloadAllTiles);
        elements.downloadSingleBtn.addEventListener('click', showTileDownloadModal);
        
        setupCanvasInteractions();
    }

    function setupCanvasInteractions() {
        // 优化移动端和桌面端事件
        state.imageCanvas.addEventListener('mousedown', handleMouseDown);
        state.imageCanvas.addEventListener('mousemove', handleMouseMove);
        state.imageCanvas.addEventListener('mouseup', handleMouseUp);
        state.imageCanvas.addEventListener('wheel', handleWheel, { passive: false });
        state.imageCanvas.addEventListener('mouseleave', handleMouseUp);
        
        // 触摸事件
        state.imageCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        state.imageCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        state.imageCanvas.addEventListener('touchend', handleTouchEnd);
        state.imageCanvas.addEventListener('touchcancel', handleTouchEnd);
    }

    function handleUploadClick() {
        // 防止重复触发
        const now = Date.now();
        if (isUploading || (now - lastUploadTime < UPLOAD_COOLDOWN)) {
            return;
        }
        
        isUploading = true;
        lastUploadTime = now;
        
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.style.display = 'none';
        
        // 添加事件监听
        fileInput.addEventListener('change', function(e) {
            handleFileSelect(e);
            // 清理
            setTimeout(() => {
                if (fileInput.parentNode) {
                    fileInput.parentNode.removeChild(fileInput);
                }
                isUploading = false;
            }, 100);
        });
        
        // 添加到DOM并触发点击
        document.body.appendChild(fileInput);
        
        // 修复iOS Safari文件选择问题
        if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
            fileInput.style.position = 'fixed';
            fileInput.style.top = '50%';
            fileInput.style.left = '50%';
            fileInput.style.transform = 'translate(-50%, -50%)';
            fileInput.style.opacity = '0';
            fileInput.style.width = '100%';
            fileInput.style.height = '100%';
        }
        
        // 使用requestAnimationFrame确保触发点击
        requestAnimationFrame(() => {
            fileInput.click();
        });
        
        // 设置超时恢复状态
        setTimeout(() => {
            isUploading = false;
        }, UPLOAD_COOLDOWN);
    }

    // 移除原来的handleUploadTouch函数，使用统一的handleUploadClick

    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        if (file.size > 100 * 1024 * 1024) {
            alert('文件大小超过100MB限制！');
            isUploading = false;
            return;
        }
        
        state.fileName = file.name.replace(/\.[^/.]+$/, "");
        
        showProgress('正在加载图片...', 10);
        
        const reader = new FileReader();
        
        reader.onload = function(e) {
            const img = new Image();
            
            img.onload = function() {
                state.originalImage = img;
                state.image = img;
                state.originalImageSize = {
                    width: img.width,
                    height: img.height
                };
                
                // 计算最小尺寸i：长和宽较小者
                state.minDimension = Math.min(img.width, img.height);
                
                calculateDefaultCrop(img);
                // 计算最小允许缩放比例
                calculateMinScale();
                updateBoundaries();
                clampOffsetToBoundaries();
                drawImage();
                drawGrid();
                
                elements.downloadBtn.disabled = false;
                elements.downloadSingleBtn.disabled = false;
                
                hideProgress();
                isUploading = false;
            };
            
            img.onerror = function() {
                alert('图片加载失败，请尝试其他图片！');
                hideProgress();
                isUploading = false;
            };
            
            img.src = e.target.result;
        };
        
        reader.onerror = function() {
            alert('文件读取失败，请重试！');
            hideProgress();
            isUploading = false;
        };
        
        reader.readAsDataURL(file);
    }

    function calculateDefaultCrop(img) {
        const gridSize = state.cropState.gridSize;
        const imgAspect = img.width / img.height;
        
        let scale, offsetX, offsetY;
        
        if (imgAspect > 1) {
            // 宽图：高度填满，宽度居中
            scale = gridSize / img.height;
            offsetX = (gridSize - img.width * scale) / 2;
            offsetY = 0;
        } else {
            // 高图或方图：宽度填满，高度居中
            scale = gridSize / img.width;
            offsetX = 0;
            offsetY = (gridSize - img.height * scale) / 2;
        }
        
        state.cropState.defaultScale = scale;
        state.cropState.defaultOffsetX = offsetX;
        state.cropState.defaultOffsetY = offsetY;
        
        state.cropState.scale = scale;
        state.cropState.offsetX = offsetX;
        state.cropState.offsetY = offsetY;
    }

    // 计算最小允许缩放比例
    function calculateMinScale() {
        if (!state.image || state.minDimension === 0) return;
        
        const img = state.image;
        const gridSize = state.cropState.gridSize;
        
        // 确保缩放后图片能完全覆盖九宫格
        // 计算两个维度的最小缩放比例
        const minScaleX = gridSize / img.width;
        const minScaleY = gridSize / img.height;
        
        // 取两者中较大的值，确保图片能覆盖九宫格
        const requiredMinScale = Math.max(minScaleX, minScaleY);
        
        // 设置最小允许缩放比例
        state.cropState.minAllowedScale = Math.max(requiredMinScale, 0.1);
    }

    // 应用缩放并调整位置
    function applyScale(newScale) {
        if (!state.image) return false;
        
        const crop = state.cropState;
        const canvas = state.imageCanvas;
        const img = state.image;
        
        // 限制缩放范围
        newScale = Math.max(crop.minAllowedScale, Math.min(crop.maxScale, newScale));
        
        // 计算缩放中心（canvas中心）
        const centerX = canvas.width / (window.devicePixelRatio || 1) / 2;
        const centerY = canvas.height / (window.devicePixelRatio || 1) / 2;
        
        // 计算相对于中心点的偏移量变化
        const scaleRatio = newScale / crop.scale;
        
        // 调整偏移量，使缩放中心保持不变
        crop.offsetX = centerX - (centerX - crop.offsetX) * scaleRatio;
        crop.offsetY = centerY - (centerY - crop.offsetY) * scaleRatio;
        
        // 更新缩放比例
        crop.scale = newScale;
        
        // 更新边界并限制位置
        updateBoundaries();
        clampOffsetToBoundaries();
        
        return true;
    }

    function updateBoundaries() {
        if (!state.image) return;
        
        const crop = state.cropState;
        const canvas = state.imageCanvas;
        const img = state.image;
        
        // 考虑设备像素比
        const dpr = window.devicePixelRatio || 1;
        const canvasWidth = canvas.width / dpr;
        const canvasHeight = canvas.height / dpr;
        
        const scaledWidth = img.width * crop.scale;
        const scaledHeight = img.height * crop.scale;
        
        // 计算最大偏移量，确保图片边缘不会超出canvas
        crop.maxOffsetX = Math.max(0, (canvasWidth - scaledWidth) / 2);
        crop.minOffsetX = Math.min(0, canvasWidth - scaledWidth - crop.maxOffsetX);
        
        crop.maxOffsetY = Math.max(0, (canvasHeight - scaledHeight) / 2);
        crop.minOffsetY = Math.min(0, canvasHeight - scaledHeight - crop.maxOffsetY);
        
        // 确保minOffset不大于maxOffset
        if (crop.minOffsetX > crop.maxOffsetX) {
            crop.minOffsetX = crop.maxOffsetX = (canvasWidth - scaledWidth) / 2;
        }
        
        if (crop.minOffsetY > crop.maxOffsetY) {
            crop.minOffsetY = crop.maxOffsetY = (canvasHeight - scaledHeight) / 2;
        }
    }

    function clampOffsetToBoundaries() {
        const crop = state.cropState;
        crop.offsetX = Math.max(crop.minOffsetX, Math.min(crop.maxOffsetX, crop.offsetX));
        crop.offsetY = Math.max(crop.minOffsetY, Math.min(crop.maxOffsetY, crop.offsetY));
    }

    function drawImage() {
        if (!state.image) return;
        
        const ctx = state.imageCtx;
        const canvas = state.imageCanvas;
        const img = state.image;
        const crop = state.cropState;
        
        // 考虑设备像素比
        const dpr = window.devicePixelRatio || 1;
        const canvasWidth = canvas.width / dpr;
        const canvasHeight = canvas.height / dpr;
        
        // 清除Canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 绘制背景
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        
        // 完全禁用图像平滑，保持原始质量
        ctx.imageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;
        
        // 保存上下文状态
        ctx.save();
        
        // 绘制图片
        ctx.drawImage(
            img,
            0, 0, img.width, img.height,
            crop.offsetX, crop.offsetY, 
            img.width * crop.scale, img.height * crop.scale
        );
        
        ctx.restore();
    }

    function drawGrid() {
        const ctx = state.gridCtx;
        const canvas = state.gridCanvas;
        const gridSize = state.cropState.gridSize;
        
        // 考虑设备像素比
        const dpr = window.devicePixelRatio || 1;
        
        // 清除Canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const cellSize = gridSize / 3;
        
        // 绘制发光的分割线
        for (let i = 1; i < 3; i++) {
            // 垂直分割线
            ctx.beginPath();
            ctx.moveTo(i * cellSize, 0);
            ctx.lineTo(i * cellSize, gridSize);
            
            // 发光的白色线条
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#667eea';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.stroke();
            
            // 增强发光效果
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 1.5;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 6;
            ctx.stroke();
        }
        
        for (let i = 1; i < 3; i++) {
            // 水平分割线
            ctx.beginPath();
            ctx.moveTo(0, i * cellSize);
            ctx.lineTo(gridSize, i * cellSize);
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#667eea';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.stroke();
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 1.5;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 6;
            ctx.stroke();
        }
        
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        
        // 绘制边框 - 发光效果
        ctx.strokeStyle = 'rgba(102, 126, 234, 0.8)';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#667eea';
        ctx.shadowBlur = 12;
        ctx.strokeRect(1, 1, gridSize - 2, gridSize - 2);
        
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
    }

    function drawPlaceholder() {
        const ctx = state.imageCtx;
        const canvas = state.imageCanvas;
        const gridSize = state.cropState.gridSize;
        
        // 考虑设备像素比
        const dpr = window.devicePixelRatio || 1;
        const canvasWidth = canvas.width / dpr;
        const canvasHeight = canvas.height / dpr;
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        
        const cellSize = gridSize / 3;
        
        ctx.strokeStyle = 'rgba(226, 232, 240, 0.8)';
        ctx.lineWidth = 1;
        
        for (let i = 1; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(i * cellSize, 0);
            ctx.lineTo(i * cellSize, gridSize);
            ctx.stroke();
        }
        
        for (let i = 1; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(0, i * cellSize);
            ctx.lineTo(gridSize, i * cellSize);
            ctx.stroke();
        }
        
        ctx.fillStyle = 'rgba(120, 113, 108, 0.4)';
        ctx.font = 'bold 22px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('等待图片上传', gridSize/2, gridSize/2);
        
        state.gridCtx.clearRect(0, 0, state.gridCanvas.width, state.gridCanvas.height);
    }

    function handleMouseDown(e) {
        if (!state.image) return;
        
        e.preventDefault();
        const rect = state.imageCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        state.cropState.isDragging = true;
        state.cropState.lastX = x;
        state.cropState.lastY = y;
        
        state.imageCanvas.style.cursor = 'grabbing';
    }

    function handleMouseMove(e) {
        if (!state.image || !state.cropState.isDragging) return;
        
        e.preventDefault();
        const rect = state.imageCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const dx = x - state.cropState.lastX;
        const dy = y - state.cropState.lastY;
        
        state.cropState.offsetX += dx;
        state.cropState.offsetY += dy;
        
        clampOffsetToBoundaries();
        
        state.cropState.lastX = x;
        state.cropState.lastY = y;
        
        drawImage();
    }

    function handleMouseUp() {
        if (!state.image) return;
        
        state.cropState.isDragging = false;
        state.imageCanvas.style.cursor = 'move';
    }

    function handleWheel(e) {
        if (!state.image) return;
        
        e.preventDefault();
        
        // 计算缩放方向
        const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05;
        const currentScale = state.cropState.scale;
        const newScale = currentScale * zoomFactor;
        
        // 应用缩放
        const success = applyScale(newScale);
        
        if (success) {
            // 重绘
            drawImage();
            drawGrid();
        }
    }

    function handleTouchStart(e) {
        if (!state.image) return;
        
        e.preventDefault();
        const touches = e.touches;
        
        if (touches.length === 1) {
            const rect = state.imageCanvas.getBoundingClientRect();
            const touch = touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            state.cropState.isDragging = true;
            state.cropState.lastX = x;
            state.cropState.lastY = y;
            state.cropState.lastDistance = 0;
        } else if (touches.length === 2) {
            const touch1 = touches[0];
            const touch2 = touches[1];
            
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            state.cropState.lastDistance = distance;
            state.cropState.lastScale = state.cropState.scale;
            state.cropState.isDragging = false;
        }
    }

    function handleTouchMove(e) {
        if (!state.image) return;
        
        e.preventDefault();
        const touches = e.touches;
        
        if (touches.length === 1 && state.cropState.isDragging) {
            const rect = state.imageCanvas.getBoundingClientRect();
            const touch = touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            const dx = x - state.cropState.lastX;
            const dy = y - state.cropState.lastY;
            
            state.cropState.offsetX += dx;
            state.cropState.offsetY += dy;
            
            clampOffsetToBoundaries();
            
            state.cropState.lastX = x;
            state.cropState.lastY = y;
            
            drawImage();
        } else if (touches.length === 2) {
            const touch1 = touches[0];
            const touch2 = touches[1];
            
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (state.cropState.lastDistance > 0) {
                const scaleChange = distance / state.cropState.lastDistance;
                const currentScale = state.cropState.scale;
                const newScale = currentScale * scaleChange;
                
                // 应用缩放
                const success = applyScale(newScale);
                
                if (success) {
                    // 重绘
                    drawImage();
                    drawGrid();
                }
            }
            
            state.cropState.lastDistance = distance;
        }
    }

    function handleTouchEnd(e) {
        if (!state.image) return;
        
        state.cropState.isDragging = false;
        state.cropState.lastDistance = 0;
    }

    function resetCrop() {
        if (!state.image) return;
        
        state.cropState.scale = state.cropState.defaultScale;
        state.cropState.offsetX = state.cropState.defaultOffsetX;
        state.cropState.offsetY = state.cropState.defaultOffsetY;
        
        updateBoundaries();
        
        drawImage();
        drawGrid();
    }

    function showProgress(text, progress) {
        elements.progressContainer.style.display = 'block';
        elements.progressText.textContent = text;
        elements.progressFill.style.width = `${progress}%`;
    }

    function hideProgress() {
        elements.progressContainer.style.display = 'none';
    }

    function showTileDownloadModal() {
        if (!state.image) return;
        
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        
        modal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <i class="fas fa-cubes"></i> 选择下载部分
                    </h2>
                    <p style="color: #718096; margin-top: 10px; text-align: center;">点击选择要单独下载的部分</p>
                </div>
                
                <div class="tile-grid">
                    ${chineseNumbers.map((text, index) => `
                        <button class="tile-btn" data-index="${index + 1}">
                            <span>${text}</span>
                        </button>
                    `).join('')}
                </div>
                
                <div class="modal-actions">
                    <button class="modal-btn modal-primary" id="modalDownloadAll">
                        <i class="fas fa-file-archive"></i> 打包下载
                    </button>
                    <button class="modal-btn modal-secondary" id="modalClose">
                        <i class="fas fa-times"></i> 关闭
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        modal.querySelectorAll('.tile-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const index = parseInt(e.currentTarget.dataset.index);
                downloadSingleTile(index);
                document.body.removeChild(modal);
            });
        });
        
        modal.querySelector('#modalDownloadAll').addEventListener('click', () => {
            document.body.removeChild(modal);
            downloadAllTiles();
        });
        
        modal.querySelector('#modalClose').addEventListener('click', () => {
            document.body.removeChild(modal);
        });
        
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        });
        
        const handleEscKey = (e) => {
            if (e.key === 'Escape') {
                document.body.removeChild(modal);
                document.removeEventListener('keydown', handleEscKey);
            }
        };
        
        document.addEventListener('keydown', handleEscKey);
    }

    // 完全保持原始图片质量的切割函数，不添加白边
    async function downloadAllTiles() {
        if (!state.image) return;
        
        showProgress('正在生成高清九宫格切图...', 10);
        
        try {
            const zip = new JSZip();
            const img = state.originalImage;
            const crop = state.cropState;
            const originalSize = state.originalImageSize;
            const gridSize = crop.gridSize;
            const cellSize = gridSize / 3;
            
            // 处理每个单元格
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const index = row * 3 + col + 1;
                    
                    // 计算Canvas中的单元格位置
                    const canvasX = col * cellSize;
                    const canvasY = row * cellSize;
                    
                    // 将Canvas坐标转换为原始图片坐标
                    const imgX = (canvasX - crop.offsetX) / crop.scale;
                    const imgY = (canvasY - crop.offsetY) / crop.scale;
                    const imgWidth = cellSize / crop.scale;
                    const imgHeight = cellSize / crop.scale;
                    
                    // 计算原始图片中实际可用的像素区域（精确到像素）
                    const pixelX = Math.max(0, Math.floor(imgX));
                    const pixelY = Math.max(0, Math.floor(imgY));
                    const pixelWidth = Math.max(0, Math.floor(Math.min(originalSize.width - pixelX, imgWidth)));
                    const pixelHeight = Math.max(0, Math.floor(Math.min(originalSize.height - pixelY, imgHeight)));
                    
                    // 如果完全在图片外，创建透明图片
                    if (pixelWidth <= 0 || pixelHeight <= 0) {
                        const outputCanvas = document.createElement('canvas');
                        const outputCtx = outputCanvas.getContext('2d');
                        
                        outputCanvas.width = 1;
                        outputCanvas.height = 1;
                        
                        outputCtx.imageSmoothingEnabled = false;
                        outputCtx.mozImageSmoothingEnabled = false;
                        outputCtx.webkitImageSmoothingEnabled = false;
                        outputCtx.msImageSmoothingEnabled = false;
                        
                        // 完全透明的背景
                        outputCtx.clearRect(0, 0, 1, 1);
                        
                        const imageDataUrl = outputCanvas.toDataURL('image/png', 1.0);
                        const byteString = atob(imageDataUrl.split(',')[1]);
                        const mimeString = imageDataUrl.split(',')[0].split(':')[1].split(';')[0];
                        const ab = new ArrayBuffer(byteString.length);
                        const ia = new Uint8Array(ab);
                        
                        for (let i = 0; i < byteString.length; i++) {
                            ia[i] = byteString.charCodeAt(i);
                        }
                        
                        const imageBlob = new Blob([ab], { type: mimeString });
                        const fileName = `${state.fileName || '九宫格'}_${chineseNumbers[index-1]}.png`;
                        zip.file(fileName, imageBlob);
                    } else {
                        // 有实际图片内容
                        const outputWidth = pixelWidth;
                        const outputHeight = pixelHeight;
                        
                        const outputCanvas = document.createElement('canvas');
                        const outputCtx = outputCanvas.getContext('2d');
                        
                        outputCanvas.width = outputWidth;
                        outputCanvas.height = outputHeight;
                        
                        // 完全禁用图像平滑
                        outputCtx.imageSmoothingEnabled = false;
                        outputCtx.mozImageSmoothingEnabled = false;
                        outputCtx.webkitImageSmoothingEnabled = false;
                        outputCtx.msImageSmoothingEnabled = false;
                        
                        // 直接提取原始图片区域，不缩放，不添加白边
                        outputCtx.drawImage(
                            img,
                            pixelX, pixelY, outputWidth, outputHeight,
                            0, 0, outputWidth, outputHeight
                        );
                        
                        // 获取PNG格式的图像数据，完全不压缩
                        const imageDataUrl = outputCanvas.toDataURL('image/png', 1.0);
                        
                        // 转换为Blob
                        const byteString = atob(imageDataUrl.split(',')[1]);
                        const mimeString = imageDataUrl.split(',')[0].split(':')[1].split(';')[0];
                        const ab = new ArrayBuffer(byteString.length);
                        const ia = new Uint8Array(ab);
                        
                        for (let i = 0; i < byteString.length; i++) {
                            ia[i] = byteString.charCodeAt(i);
                        }
                        
                        const imageBlob = new Blob([ab], { type: mimeString });
                        
                        // 添加到ZIP
                        const fileName = `${state.fileName || '九宫格'}_${chineseNumbers[index-1]}.png`;
                        zip.file(fileName, imageBlob);
                    }
                    
                    // 更新进度
                    const progress = 10 + (index / 9) * 80;
                    showProgress(`正在生成高清${chineseNumbers[index-1]}...`, progress);
                    
                    await new Promise(resolve => setTimeout(resolve, 30));
                }
            }
            
            // 生成ZIP文件
            showProgress('正在打包文件...', 90);
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            
            // 创建下载链接
            const downloadUrl = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = downloadUrl;
            a.download = `${state.fileName || '九宫格切图'}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            setTimeout(() => URL.revokeObjectURL(downloadUrl), 100);
            
            showProgress('下载完成！', 100);
            setTimeout(hideProgress, 1000);
            
        } catch (error) {
            console.error('生成切图时出错:', error);
            alert('生成切图时出错，请重试！');
            hideProgress();
        }
    }

    // 下载单个切图 - 完全保持原始质量，不添加白边
    function downloadSingleTile(index) {
        if (!state.image) return;
        
        const img = state.originalImage;
        const crop = state.cropState;
        const originalSize = state.originalImageSize;
        const gridSize = crop.gridSize;
        const cellSize = gridSize / 3;
        
        // 计算行和列
        const row = Math.floor((index - 1) / 3);
        const col = (index - 1) % 3;
        
        // 计算Canvas中的单元格位置
        const canvasX = col * cellSize;
        const canvasY = row * cellSize;
        
        // 将Canvas坐标转换为原始图片坐标
        const imgX = (canvasX - crop.offsetX) / crop.scale;
        const imgY = (canvasY - crop.offsetY) / crop.scale;
        const imgWidth = cellSize / crop.scale;
        const imgHeight = cellSize / crop.scale;
        
        // 计算原始图片中实际可用的像素区域
        const pixelX = Math.max(0, Math.floor(imgX));
        const pixelY = Math.max(0, Math.floor(imgY));
        const pixelWidth = Math.max(0, Math.floor(Math.min(originalSize.width - pixelX, imgWidth)));
        const pixelHeight = Math.max(0, Math.floor(Math.min(originalSize.height - pixelY, imgHeight)));
        
        // 创建输出Canvas
        const outputCanvas = document.createElement('canvas');
        const outputCtx = outputCanvas.getContext('2d');
        
        // 设置输出Canvas尺寸为实际像素区域大小
        outputCanvas.width = pixelWidth;
        outputCanvas.height = pixelHeight;
        
        // 完全禁用图像平滑
        outputCtx.imageSmoothingEnabled = false;
        outputCtx.mozImageSmoothingEnabled = false;
        outputCtx.webkitImageSmoothingEnabled = false;
        outputCtx.msImageSmoothingEnabled = false;
        
        if (pixelWidth <= 0 || pixelHeight <= 0) {
            // 如果完全在图片外，创建透明图片
            outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
        } else {
            // 直接提取原始图片区域，不缩放，不添加白边
            outputCtx.drawImage(
                img,
                pixelX, pixelY, pixelWidth, pixelHeight,
                0, 0, pixelWidth, pixelHeight
            );
        }
        
        // 获取PNG格式的图像数据，完全不压缩
        outputCanvas.toBlob(blob => {
            const downloadUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = downloadUrl;
            a.download = `${state.fileName || '九宫格'}_${chineseNumbers[index-1]}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            setTimeout(() => URL.revokeObjectURL(downloadUrl), 100);
        }, 'image/png', 1.0);
    }

    // 初始化应用
    window.addEventListener('DOMContentLoaded', init);
    
    // 处理页面可见性变化（移动端优化）
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden && state.image) {
            // 页面重新可见时，重新绘制
            setTimeout(() => {
                updateCanvasSize();
                drawImage();
                drawGrid();
            }, 100);
        }
    });
    
    // 防止移动端缩放
    document.addEventListener('gesturestart', function(e) {
        e.preventDefault();
    });
    
    // 处理移动端键盘弹出
    window.addEventListener('resize', function() {
        if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
            // 键盘弹出时，可能需要调整布局
            setTimeout(handleResize, 300);
        }
    });
</script>

</body>
</html>